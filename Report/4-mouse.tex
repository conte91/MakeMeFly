\section{CPLD-based mouse control}
A small CPLD (Altera EPM7032) has been used to interface with a mouse's buttons. The Quartus II IDE has been used for design synthesis and the device has been programmed using a BusPirate serial interface together with OpenOCD.

From an external point of view, the three mouse's buttons change the position reference of the levitating object: when button 1 (left) is pressed, the position of the object is decreased (the object goes down). When button 2 (right) is pressed, the position is increased (the object goes up), while when button 3 (center) is pressed the position is reset to the initial value.

Electrically, the buttons are seen as simple switches, with a built-in forward-biased protection diode. This makes it impossible to feed them with 3.3V inputs, as the output would be lowered to 2.7V. So, the 5V rail is used as an input for the buttons, which close to pull-down networks made of a 100$\Omega$ resistor in serie with a 3.3V zener diode and a 10K$\Omega$ resistor. When the switch is open, the two resistor act as a single pull-down resistor and bring the output to 0V. When the button is pressed, the zener diode in serie with the 100$\Omega$ resistor regulates the output voltage to 3.3V, which is a correct value for the input pins of the CPLD.

The digital part of the CPLD consists of a register, the value of which is put in output and connected to the Stellaris microcontroller, keeping the value of the desired's magnetic field of the permanent magnet (i.e. the desired position of the levitating object). The buttons are sampled at a low rate (25Hz), which clock signal is generated by an external LM555-based oscillator. This low rate is necessary to also implement debouncing of the buttons. For each button two flip-flops keep the current and previous sampled value. An \pre{or} gate decides at each instant if at least one of the button has been pressed, and is used as a clock signal for the main process. On its falling edge (i.e. when buttons are released) the previous samples of the buttons are checked to see which button has just been released: if it's button number 1, the register content is increased by 1, otherwise it is decreased. Button 3, together with an external reset signal connected to the microcontroller, acts as an asynchronous reset of the register.

The desired position is kept in memory and is communicated to the microcontroller divided by 16 (i.e. last 4 bits are omitted and set to 0), thus with an 8-bit output the range 0-4080 is reachable. When reset, the position is set to 2032 (half of the range).

To avoid overflows and underflows, before modifying the register's value it is checked to be 0xFF or 0x0F: in these cases, the value isn't allowed to grow (when 0xFF) or to decrease (when 0x0F) and LEDs are turned on into the main board to indicated overflow or underflow occoured.

