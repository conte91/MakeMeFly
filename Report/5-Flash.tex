\section{Flash memory interface}
An AMIO flash memory is used by the microcontroller to store its calibration constants (reference and swing of the magnetic field, charging and discharging rates, controller's constant and proportional gains). When read and written, these values are stored into a float array which is then casted to \pre{char*}. This makes it easy to iterate over the array and save it as a byte sequence.

The flash memory interfaces the microcontroller as a 1MHz SPI slave device. The SPI interface on the Stellaris microcontroller acts as master and is connected accordingly to the memory's pins. This memory's interface has CS high, CPOL=0, CPOH=0. Two additional, active-low pins of the memory can be used to stop the communication ($\overline{HOLD}$, which is left connected to Vcc) and to enable write protection ($\overline{W}$ - this must be actively driven by the microcontroller so that accidentally erasing the memory is virtually impossible).

From the interface point of view, the memory is composed of a controller, receiving commands, each of which is initiated and terminated by pulling CS low and high (if CS is pulled high in the middle of a multy-byte command, it is discarded). As the microcontroller's SPI interface toggles CS after each byte, manually driving the CS pin is needed. Command start with a byte indicating the command type, and are followed by writes of parameters for the commands and optionally reads of commands' results. Besides the controller, the memory is organized in pages, each of which is organized in sectors. Each sector must be erased as a whole (which resets every byte of it to 0xFF) but can be written starting at non-aligned addresses if needed.

The flash memory also contains a 8-bit status register, which can be read to ensure write operations have been enabled, and to wait until they are completed before sending new commands.

It is important to know that the programming operation is only capable of setting bits from 1 to 0: thus, when writing to a particular memory location, it is needed first to erase the corresponding sector, otherwise 0-valued bits will not change.

At start, the microcontroller sends the \pre{Device ID} (0x9F) command, which lets the device communicate its manufacturer's ID. It is checked to be 0x373014 as specified into the datasheet. If this succeds, the flash memory is configured and connected correctly.

To read the calibration constants from flash, the \pre{read} (0x03) command is sent, followed by the 3-bytes address of the data to be read. Then, data read is started by sending dummy bytes (as SPI is always a full-duplex protocol); as the controller increments automatically the read address after sending each byte, all the constants can be read with a single command. If the read memory area is non initialized, all the read data will be stuck at 0xFF. As calibration constants are stored as float, this will correspond to \pre{NaN}. Thus, a simple test can be performed, as in C \pre{NaN!=NaN}: if a read constant is different from itself, this means it was not initialized into memory and it must be set to a default value.

When the PC requests to save new calibration data to memory, first the \pre{Write Enable} command is sent, followed by \pre{Read status register} to ensure that write protection has been disabled and the memory is ready for receiving new data. Then, the sector corresponding to the write address is erased with the \pre{Erase sector} command, and the status register is polled to wait for this operation to complete. Afterwards, the \pre{write} (0x02) command is sent, followed by the 3-byte address and by the bytes to be stored starting at that address. The status register is polled again to wait for write completion. Finally, calibration constants are read again and matched to the actual ones to be sure they have been written correctly.
